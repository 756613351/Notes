Spring知识点记录
1.面向接口编程(面向抽象的编程)
2.应用分层:entity,service,dao,daoimpl,utils...
3.Spring原理(个人理解)
	(1)Spring的配置文件中有beans根节点,bean子节点,bean中有一系列的属性
	(2)关于bean的属性:id:用于标示,class:映射的类,property:与其他bean的关联,将关系设定清楚之后可以实现使用一个类的时候,可以直接将
		与其有关联的类一并获取到(个人认为这是主要优势)
	(3)ClassPathXmlApplicationContext类:对Spring的xml配置文件进行解析,包括bean的属性以及bean包含的property,然后将解析到的数据放到一个
		容器中(Map容器),接着又进行了一些操作处理,比如执行set方法(这样可以在以后从容器中获取到对象之后直接使用,不需要new一个新的对象)
	(4)ClassPathXmlApplicationContext类同时实现了BeanFasctory接口,而BeanFactory接口中定义了getBean()方法,用于读取配置文件中bean的id值,
		相当于定义了一个从容器中获取数据的通道
	(6)使用:直接通过从ClassPathXmlApplicationContext容器中调用getBean()方法即可获取到所需对象(这里获取到的实际上是对象的id,然后通过反射
		找到对应的类)
4.Spring优势以及重点:
	(1)轻量级框架
	*(2)IoC容器 --- 控制反转
	*(3)AOP 面向切面编程
	*(4)对事物的支持
	*(5)对框架的支持(整合现有技术)
5.使用IoC创建对象的3种方式(了解)
	(1)无参构造方法来创建(默认,常用):要有参数的set和get方法(主要是set)
	(2)有参构造方法来创建:
		重写对象类的有参构造方法,参数为需要传递的属性值
		在配置文件中对参数赋值方式:
			[1]参数下标(index)的方式
			[2]参数名称的方式(name)
			[3]参数类型(type)
	(3)创建动/静态工厂:创建一个user工厂,返回user对象,仍然使用了user的有参构造方法
6.Spring配置文件
	bean:最常用的,用于设置类对象,
		id为标识符,具有唯一性,没有设置id,则name默认为标识符,若果配置了id,又配置了name,那么name为别名,此时name
		可以设置多个别名,中间可以用",",";"和" "分开
		class是bean的全限定名=包名+类名
		如果不配置id和name,那么可以根据applicationContext.getBean(Class)来获取对象,但是两个类名一样的话就行不通
	alias:为bean设置别名,可以设置多个别名(不过没什么必要)
	import:引入其他的配置文件,一般用于团队协作开发
7.Spring注入(重点)
	(1)构造器注入(见IOC创建对象)
	*(2)setter注入:要求被注入的属性必须有set方法
	 (3)P,C命名空间注入
8.bean的作用域(了解)
	singleton:单例(默认)
	prototype:原型,每次获取bean都会产生一个新的对象(整合框架是使用该模式)
	request:发出请求时产生新的对象
	session:在会话范围内一个对象
	global session:只在portlet下有用,表示application
	application:在应用范围内一个对象
9.autowire自动装配(了解)
	作用:简化配置文件
	byName:根据名称(set方法名后边部分,可能会与属性名不一致)去查找相应的bean,
	byType(不建议使用):根据类型自动装配,这种模式下不需要bean的id,但是同一种类型的bean只有一个
	constructor:当通过构造器实例化bean时,使用byType装配构造方法
	全局自动装配需要在头文件中添加default-autowire属性
	推荐不使用自动装配,而使用annotation
10.静态代理(重点)
	角色分析:
		抽象角色:一般使用接口或者抽象类来实现
		真实角色:被代理的角色
		代理角色:代理真实角色,代理之后一般会做一些附属的操作
		客户:使用代理角色来进行一些操作
	好处:使得真实角色处理的业务更加纯粹,不再去关注一些公共的事情
		公共的业务由代理来完成,实现了业务的分工
		公共业务发生拓展时,变得更加集中和方便
	缺点:类变多了,多了一个代理类;工作量变大了;工作效率降低
11.动态代理
	分类:
		基于接口:eg:jdk动态代理
		基于类:eg:hibernate使用的cglib
	现在使用javasist来生成动态代理
	使用:一个动态代理一般代理某一类业务,一个动态可以代理多个类(或者接口)
12.AOP
	(1)定义:Aspect Oriented Pragramming ,面向切面编程
	(2)在Spring中的作用:
		提供声明式服务(声明事务)
		允许用户自定义切面
	aop在不改变原来代码的情况下,增加新的功能,AOP属于横向编程模式,通过代理的方式实现的
	(3)好处:同代理的好处
	(4)名词解释:
		关注点:增加的某个业务,如日志,安全,缓存,事务,异常等等
		切面:一个关注点的模块化
		连接点:只某个方法的执行
		通知:在切面的某个特定的连接点上执行的动作
		织入:把切面连接到其他的应用程序类型或者对象上,病创建一个被通知的对象
	(5)AOP在Spring中实现
		[1]通过Spring API实现
			实现MethodBeforeActive接口需要导入 aopallianc.jar(该jar包需要自行下载)
			使用aop还需要另外一个jar文件:aspectj-weaver.jar
		[2]自定义类实现
		*[3]注解实现
	(6)AOP思想:AOP是将公共业务(如日志,安全)和领域业务结合,当执行领域业务时,将会把公共业务加进来.实现公共业务的重复利用,领域业务更纯粹,
		程序员专注于领域业务,其本质还是动态代理的封装
13.Spring mybatis 整合
	[1]整合必备jar:mybatis-spring-xxx.jar	(除了两个框架自身的jar之外还需此jar)
	[2]整合方案:
		1)xxDaoImpl实现SqlSessionTemplate接口,同时在配置文件中配置sqlSessionTemplate(具体见/Spring_Mybatis_010项目中Spring配置)
		2)xxDaoImpl继承SqlSessionDaoSupport类,不需要配置sqlSessionTemplate(具体见/Spring_Mybatis_020项目中Spring配置)
		3)使用mybatis注解,xxDaoImpl不需要继承类也不需要实现接口,在其类中定义xxMapper,并生成set方法,配置文件中需要配置xxMapper
			(具体见/Spring_Mybatis_030项目中Spring配置)
		4)不用Mybatis的配置文件,同时使用注解(不需要配置xxMapper.xml)(mybatis-spring-1.3.jar开始支持),在配置sqlSessionFactory的时候
			使用configuration属性(具体见/Spring_Mybatis_040项目中Spring配置)	//个人推荐使用
14.Struts-Spring-Mybatis整合
	[1]jar包管理:主要解决公共jar包以及整合以来jar包问题
		公共jar:日志类jar:commens-logging.xxx.jar ,log4j,javaassist 等等
		依赖jar:struts2-spring-plugin-xxx.jar	//Struts-Spring整合所依赖的jar
				mybatis-spring-xxx.jar 	//Mybatis-Spring整合依赖的jar
	[2]Struts2使用set,get方法无法获取到前台form传递的值问题
		在Spring AOP中对事物的范围设置太广,导致Struts的请求也被拦截
		一般设置事物范围为:service层:
			<aop:pointcut expression="execution(* com.demo.service.impl..*.*(..))" id="point"/>
15.Spring使用注解
	daoImpl-----@Repository("xxxDao")
	serviceImpl----@Service("xxxService")
	action----@Controller("xxxAction")  @Scope("prototype")
	属性----@Autowired

	
		
	
		
		
		
	
	
	
	
		
	

	
	
	
	
	
	

		
	

	
	
	
	
	
	
	
	
	
